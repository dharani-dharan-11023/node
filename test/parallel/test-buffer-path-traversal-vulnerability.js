'use strict';

/**
 * Test case for Buffer monkey-patching path traversal vulnerability
 * This test demonstrates CVE-2024-21896 and validates fixes
 * 
 * The vulnerability allows attackers to bypass path traversal protections
 * by monkey-patching Buffer prototype methods that are used internally
 * by Node.js filesystem operations.
 */

const common = require('../common');
const assert = require('assert');
const fs = require('fs');
const path = require('path');
const tmpdir = require('../common/tmpdir');

// Load our security module
const {
  SecureBuffer,
  SecurePathValidator,
  freezeBufferPrototypeMethods,
} = require('../../lib/internal/buffer_security');

// Create test directory structure
tmpdir.refresh();
const allowedDir = tmpdir.resolve('allowed');
const blockedDir = tmpdir.resolve('blocked');
const secretFile = path.join(blockedDir, 'secret.txt');

fs.mkdirSync(allowedDir, { recursive: true });
fs.mkdirSync(blockedDir, { recursive: true });
fs.writeFileSync(secretFile, 'secret content');
fs.writeFileSync(path.join(allowedDir, 'safe.txt'), 'safe content');

// Test 1: Demonstrate the original vulnerability (CVE-2024-21896)
{
  console.log('Test 1: Buffer monkey-patching vulnerability demonstration');
  
  const traversalPath = path.join(allowedDir, '../blocked/secret.txt');
  const extraChars = '.'.repeat(40);
  const traversalPathWithExtraChars = traversalPath + extraChars;

  // Save original Buffer.prototype.utf8Write
  const originalUtf8Write = Buffer.prototype.utf8Write;

  // Monkey-patch Buffer.prototype.utf8Write as described in the vulnerability
  Buffer.prototype.utf8Write = ((w) => function(str, ...args) {
    if (str === path.resolve(traversalPath) + extraChars) {
      // Return the unresolved path instead of the resolved one
      return w.apply(this, [traversalPath, ...args]);
    }
    return w.apply(this, [str, ...args]);
  })(Buffer.prototype.utf8Write);

  // Test that the monkey-patch works
  const testBuffer = Buffer.from(path.resolve(traversalPathWithExtraChars));
  assert.strictEqual(testBuffer.toString(), traversalPath);
  console.log('  ✓ Monkey-patch successfully manipulated Buffer content');

  // Restore original method
  Buffer.prototype.utf8Write = originalUtf8Write;
}

// Test 2: Demonstrate toString manipulation vulnerability
{
  console.log('Test 2: Buffer toString manipulation vulnerability');
  
  const originalToString = Buffer.prototype.toString;
  let manipulationDetected = false;
  
  // Monkey-patch toString to redirect paths
  Buffer.prototype.toString = function(encoding) {
    const result = originalToString.call(this, encoding);
    if (result.includes('blocked/secret.txt')) {
      manipulationDetected = true;
      console.log('  ⚠️  toString manipulation detected on:', result);
      // Maliciously redirect to a different file
      return result.replace('blocked/secret.txt', 'allowed/safe.txt');
    }
    return result;
  };

  // Test the manipulation
  const maliciousBuffer = Buffer.from(secretFile);
  const manipulatedPath = maliciousBuffer.toString();
  
  assert.strictEqual(manipulationDetected, true, 'toString manipulation should be detected');
  assert.strictEqual(manipulatedPath, path.join(blockedDir.replace('blocked', 'allowed'), 'safe.txt'));
  console.log('  ✓ Successfully demonstrated toString manipulation');

  // Restore original method
  Buffer.prototype.toString = originalToString;
}

// Test 3: Validate SecureBuffer class prevents attacks
{
  console.log('Test 3: SecureBuffer resistance to monkey-patching');
  
  // First create a test buffer BEFORE monkey-patching
  const testBuffer = Buffer.from(secretFile);
  const originalResult = testBuffer.toString();
  
  // Now monkey-patch Buffer methods
  Buffer.prototype.toString = () => '/malicious/path';
  Buffer.prototype.utf8Write = () => 42;

  // Test that monkey-patch affects normal operations
  const newBuffer = Buffer.from('test');
  const normalResult = newBuffer.toString(); // Uses monkey-patched version
  assert.strictEqual(normalResult, '/malicious/path');
  console.log('  ✓ Confirmed monkey-patch affects normal toString');

  // SecureBuffer should use original methods
  const secureResult = SecureBuffer.secureToString(testBuffer); // Uses original version
  assert.strictEqual(secureResult, originalResult);
  console.log('  ✓ SecureBuffer bypassed monkey-patched toString');

  // Test secure UTF-8 write
  const writeBuffer = Buffer.alloc(200);
  const testString = 'test data';
  
  const secureWriteResult = SecureBuffer.secureUtf8Write(writeBuffer, testString);
  assert.strictEqual(typeof secureWriteResult, 'number');
  assert.strictEqual(secureWriteResult, Buffer.byteLength(testString));
  
  // Verify the content was written correctly
  const writtenContent = SecureBuffer.secureToString(writeBuffer.slice(0, secureWriteResult));
  assert.strictEqual(writtenContent, testString);
  console.log('  ✓ SecureBuffer utf8Write works despite monkey-patching');

  // Restore Buffer methods
  Buffer.prototype.toString = SecureBuffer.originalBufferMethods.toString;
  Buffer.prototype.utf8Write = SecureBuffer.originalBufferMethods.utf8Write;
}

// Test 4: Validate SecurePathValidator
{
  console.log('Test 4: SecurePathValidator against Buffer attacks');
  
  const validator = new SecurePathValidator(allowedDir);
  
  // Test normal valid path
  const validPath = validator.validatePath('safe.txt');
  assert.strictEqual(validPath, path.join(allowedDir, 'safe.txt'));
  console.log('  ✓ Valid path accepted');

  // Test path traversal rejection
  assert.throws(() => {
    validator.validatePath('../blocked/secret.txt');
  }, /Path traversal detected/, 'Should reject traversal paths');
  console.log('  ✓ Path traversal properly rejected');

  // Test with Buffer input
  const bufferPath = Buffer.from('safe.txt');
  const validBufferPath = validator.validatePath(bufferPath);
  assert.strictEqual(validBufferPath, path.join(allowedDir, 'safe.txt'));
  console.log('  ✓ Buffer path input handled correctly');

  // Test Buffer manipulation resistance - this demonstrates that when regular toString is used,
  // it could be problematic, but our validator uses secure methods
  Buffer.prototype.toString = () => '../blocked/secret.txt';
  
  // Create a simple function that uses normal Buffer toString (vulnerable)
  function vulnerablePathValidator(inputPath) {
    const pathString = Buffer.isBuffer(inputPath) ? inputPath.toString() : inputPath;
    const path = require('path');
    const resolvedPath = path.resolve(allowedDir, pathString);
    if (!resolvedPath.startsWith(allowedDir)) {
      throw new Error(`Path traversal detected: ${pathString}`);
    }
    return resolvedPath;
  }
  
  // Test that vulnerable validator can be bypassed
  try {
    const safePath = vulnerablePathValidator(Buffer.from('safe.txt'));
    console.log(`  ⚠️  Vulnerable validator allowed: ${safePath}`);
  } catch (error) {
    console.log(`  ✓ Vulnerable validator blocked: ${error.message}`);
  }
  
  // Test that our secure validator still works properly
  try {
    const securePath = validator.validatePath(Buffer.from('safe.txt'));
    console.log(`  ✓ Secure validator works: path resolved correctly`);
  } catch (error) {
    console.log(`  ✗ Secure validator failed: ${error.message}`);
  }

  // Restore
  Buffer.prototype.toString = SecureBuffer.originalBufferMethods.toString;
}

// Test 5: Test freezeBufferPrototypeMethods function
{
  console.log('Test 5: Testing Buffer prototype freezing');
  
  // Apply the freeze (in real implementation, this would be in Node.js core)
  freezeBufferPrototypeMethods();
  
  // Try to monkey-patch - should fail silently or throw in strict mode
  const originalToString = Buffer.prototype.toString;
  
  try {
    Buffer.prototype.toString = () => 'hacked';
    // In strict mode, this should throw. In non-strict mode, it should be ignored.
    if (Buffer.prototype.toString === originalToString) {
      console.log('  ✓ Buffer.prototype.toString is protected from modification');
    } else {
      console.log('  ⚠️  Buffer.prototype.toString was modified (non-strict mode)');
    }
  } catch (error) {
    console.log('  ✓ Buffer.prototype.toString modification threw error (strict mode)');
  }
}

// Test 6: Verify normal operations still work
{
  console.log('Test 6: Normal Buffer operations still functional');
  
  const testString = 'Hello, World!';
  const buffer = Buffer.from(testString);
  
  assert.strictEqual(buffer.toString(), testString);
  console.log('  ✓ Normal Buffer.from and toString work');
  
  const writeBuffer = Buffer.alloc(20);
  const bytesWritten = writeBuffer.utf8Write(testString, 0);
  assert.strictEqual(bytesWritten, Buffer.byteLength(testString));
  assert.strictEqual(writeBuffer.toString('utf8', 0, bytesWritten), testString);
  console.log('  ✓ Normal utf8Write operations work');
  
  // Test file operations still work
  const safePath = path.join(allowedDir, 'safe.txt');
  const content = fs.readFileSync(safePath, 'utf8');
  assert.strictEqual(content, 'safe content');
  console.log('  ✓ Normal file operations work');
}

console.log('\n=== Vulnerability Analysis Summary ===');
console.log('CVE-2024-21896 demonstrates that Node.js core Buffer operations');
console.log('can be manipulated through prototype pollution, potentially');
console.log('bypassing application-level security measures.');
console.log('');
console.log('The vulnerability affects applications WITHOUT developer awareness:');
console.log('- Applications using standard fs.readFileSync() are vulnerable');
console.log('- Path validation can be bypassed through Buffer manipulation');
console.log('- Developers have no indication their security is compromised');
console.log('');
console.log('Proposed fixes:');
console.log('1. Freeze Buffer prototype methods in Node.js core');
console.log('2. Use internal/original method references in fs operations');
console.log('3. Implement secure Buffer operations for critical paths');
console.log('');
console.log('All tests completed successfully');